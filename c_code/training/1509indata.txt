



#include <iostream>
#include <fstream> 
#include <cstdlib>

using namespace std;  

const int MAX_SIZE = 9;	
static int direction[8][2] = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}}; 

class KnightsTour
{ 
public:   
	KnightsTour();    
	KnightsTour(int sizeOfRow, int sizeOfCol);  
    bool buildKnightsTour(int startRow, int startCol);     
	void chessBoard(); 

private:
	typedef int boardType[MAX_SIZE][MAX_SIZE];            
	bool recurKnightsTour(int startRow, int startCol,int move);      
	bool isValid (int row, int col);  
    int sizeOfRow, sizeOfCol;     
	boardType board;	
};  
  
KnightsTour::KnightsTour()  
{ 
	sizeOfRow = sizeOfCol = 8;	
}  

KnightsTour::KnightsTour(int sRow, int sCol)
{
	if (sRow>=2 && sRow<=MAX_SIZE)	
		sizeOfRow = sRow;    
	else         
		sizeOfRow = 8;	
    
	if (sCol>=2 && sCol<=MAX_SIZE)	   
		sizeOfCol = sCol;     
	else         
		sizeOfCol = 8;	
}

void KnightsTour::chessBoard()
{     
	for (int r = 0; r < sizeOfRow; r++)    
	{         
		for (int c = 0; c < sizeOfCol; c++)             
			cout << board[r][c] << " ";  
        cout <<endl;     
	} 
}

bool KnightsTour::buildKnightsTour(int startRow, int startCol) 
{     
	for (int r=0; r<sizeOfRow; r++)         
		for (int c=0; c<sizeOfCol; c++)             
			board[r][c]= 0;	
    
	if (startRow <= 0 || startRow > sizeOfRow)         
		startRow = 0;     
	
	if (startCol <= 0 || startCol > sizeOfCol)         
		startCol = 0;  
    
	board[startRow-1][startCol-1] = 1;  
    
	return recurKnightsTour(startRow-1, startCol-1, 1); 
}

bool KnightsTour::recurKnightsTour(int row, int col, int move)
{     
	int nextRow, nextCol;

    if (move == sizeOfRow*sizeOfCol)        
		return true;          
	
	for(int dir=0; dir<8; dir++)   
	{        
		nextRow = row + direction[dir][0];  
		nextCol = col + direction[dir][1];	

        if(isValid(nextRow, nextCol))       
		{  
			board[nextRow][nextCol] = move+1;	
			if(recurKnightsTour(nextRow, nextCol, move+1))
			{ 
				return true;	
			}
			else
				board[nextRow][nextCol] = 0;	
        }     
	}          
	
	return false;
}

bool KnightsTour::isValid(int row, int col) 
{  
	if(row>=sizeOfRow || row<0)	
		return false;            
	
	if(col>=sizeOfCol || col<0)   
		return false;            
	
	if(board[row][col] != 0)    
		return false;                  
	
	else						
		return true;      
}  
   
int main(void)
{     
	ifstream inStream;     
	int numCases;  
    
	inStream.open("input.txt");     
	if (inStream.fail())   
		exit(1);     

    
	inStream >> numCases;  
    
	for(int i=0; i<numCases; i++)   
	{         
		int sizeOfRow, sizeOfCol;         
		int startRow, startCol;  
        
		inStream >> sizeOfRow >> sizeOfCol;         
		inStream >> startRow >> startCol;

        KnightsTour kTour(sizeOfRow, sizeOfCol);  
        if (kTour.buildKnightsTour(startRow, startCol))
		{           
			cout << 1 << endl;	
			kTour.chessBoard();	
		} else            
			cout << 0 << endl;  
	}    

	inStream.close();
}   