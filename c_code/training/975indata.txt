#include <iostream>
#include <fstream>

void init_g_table(int width, int height);
void make_dynamic_array(std::ifstream& file, int arr[][105], int width, int height);
int min_turn_count(int rows[][105], int cols[][105], int width, int height, int limit_fuel);
int min(int num1, int num2);
int calculate_time(int width, int height, int time, int turn_count);

int g_table[205][105][105][2];

int main()
{
	std::ifstream inFile("input.txt");

	if (inFile.fail()){
		std::cout << "input file opening fail\n" << std::endl;
		return 0;
	}

	int testCases = 0;
	inFile >> testCases;

	int height = 0;
	int width = 0;
	int time = 0;
	int limit_fuel = 0;
	int min_fuel = 0;
	int turn_count = 0;

	for (int i = 0; i < testCases; i++){
		inFile >> height >> width >> time >> limit_fuel;

		int rows[105][105] = { 0 };
		int cols[105][105] = { 0 };
		
		init_g_table(width, height);
		make_dynamic_array(inFile, rows, width - 1, height);
		make_dynamic_array(inFile, cols, width, height - 1);
		
		turn_count = min_turn_count(rows, cols, width, height, limit_fuel);

		std::cout << calculate_time(width, height, time, turn_count) << std::endl;
	}
	
	return 0;

}
void init_g_table(int width, int height){
	
	for (int i = 0; i <= width + height; i++){
		for (int j = 0; j < height; j++){
			for (int k = 0; k < width; k++){
				g_table[i][j][k][0] = g_table[i][j][k][1] = 0;
				
			}
		}
	}
}

void make_dynamic_array(std::ifstream& file, int arr[][105], int width, int height){

	for (int row = 0; row < height; row++){
		for (int col = 0; col < width; col++){
			file >> arr[row][col];
		}
	}
}

int min_turn_count(int rows[][105], int cols[][105], int width, int height, int limit_fuel){
	
	for (int k = 0; k <= height + width; k++)
	{
		for (int i = 0; i<height; i++)
		{
			for (int j = 0; j<width; j++)
			{
				if (!(i == 0 && j == 0 && k == 0))
					g_table[k][i][j][0] = g_table[k][i][j][1] = 999999999;
				
				if (j > 0){
					g_table[k][i][j][0] = min(g_table[k][i][j][0], g_table[k][i][j - 1][0] + rows[i][j - 1]);
					if (k > 0)
						g_table[k][i][j][0] = min(g_table[k][i][j][0], g_table[k - 1][i][j - 1][1] + rows[i][j - 1]);
				}
				
				if (i > 0){
					g_table[k][i][j][1] = min(g_table[k][i][j][1], g_table[k][i - 1][j][1] + cols[i - 1][j]);
					if (k > 0)
						g_table[k][i][j][1] = min(g_table[k][i][j][1], g_table[k - 1][i - 1][j][0] + cols[i - 1][j]);
				}
			}
		}
	}
	
	for (int k = 0; k <= width + height; k++)
	{
		if (g_table[k][height - 1][width - 1][1] <= limit_fuel || g_table[k][height - 1][width - 1][0] <= limit_fuel){
			return k;
		}
	}
	return -1;
}

int min(int num1, int num2){
	return num1 > num2 ? num2 : num1;
}

int calculate_time(int width, int height, int time, int turn_count){
	if (turn_count == -1){
		return -1;
	}
	else{
		return ((width + height - 2) * time) + turn_count;
	}
}