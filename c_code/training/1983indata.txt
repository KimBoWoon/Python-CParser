

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#define MAX 1000000

int data[MAX];

int compare(const void *a, const void *b);
void twoNumber(int count, int target);

int main(void) {

	FILE *in_file;
	int i, j;
	int Case_Count, Data_Count, target_number;

	in_file = fopen("input.txt", "r");
	if (in_file == NULL)
		exit(1);
	fscanf(in_file, "%d", &Case_Count);

	for (i = 0; i < Case_Count; i++)
	{
		fscanf(in_file, "%d", &Data_Count);
		fscanf(in_file, "%d", &target_number);

		for (j = 0; j < Data_Count; j++)
			fscanf(in_file, "%d", &data[j]);

		qsort(data, Data_Count, sizeof(data[0]), compare);			
		twoNumber(Data_Count, target_number);
	}

	fclose(in_file);

	getchar();
	return 0;
}

int compare(const void *a, const void *b) {							
	return *(int*)a - *(int*)b;
}

void twoNumber(int Data_Count, int target) {
	int left, right, middle, near_count = 0, near = 1000 * MAX, i, temp;
	for (i = 0; i < Data_Count; i++)
	{
		left = i, right = Data_Count - 1, middle = (right + i) / 2;	
		temp = target - data[i];										
		if (left == middle)											
		{
			if (abs(data[left] + data[right] - target) < near)		
			{
				near = abs(data[left] + data[right] - target);
				near_count = 1;
			}

			else if (abs(data[left] + data[right] - target) == near)
				near_count++;
			break;
		}

		while (1)													
		{
			if (data[middle] < temp)								
			{
				if (middle + 1 == right)							
				{
					if (abs(temp - data[middle]) == abs(temp - data[right]))	
					{
						if (near > abs(temp - data[middle]))
						{
							near = abs(temp - data[middle]);
							near_count = 2;
						}

						else if (near == abs(temp - data[middle]))
							near_count += 2;

					}

					else if (abs(temp - data[middle]) < abs(temp - data[right]))	
					{
						if (near > abs(temp - data[middle]))
						{
							near = abs(temp - data[middle]);
							near_count = 1;
						}

						else if (near == abs(temp - data[middle]))
							near_count++;
					}

					else														
					{
						if (near > abs(temp - data[right]))
						{
							near = abs(temp - data[right]);
							near_count = 1;
						}

						else if (near == abs(temp - data[right]))
							near_count++;
					}
					break;				
				}

				else						
				{
					left = middle;
					middle = (left + right) / 2;
				}
			}

			else if (data[middle] > temp)							
			{
				if (middle - 1 == left)								
				{
					if (left == i)									
					{
						if (abs(temp - data[middle]) == near)
							near_count++;
						else if (abs(temp - data[middle]) < near)
						{
							near = abs(temp - data[middle]);
							near_count = 1;
						}
					}
					else if (abs(temp - data[middle]) == abs(temp - data[left]))
					{
						if (near > abs(temp - data[middle]))
						{
							near = abs(temp - data[middle]);
							near_count = 2;
						}

						else if (near == abs(temp - data[middle]))
							near_count += 2;

					}

					else if (abs(temp - data[middle]) < abs(temp - data[left]))
					{
						if (near > abs(temp - data[middle]))
						{
							near = abs(temp - data[middle]);
							near_count = 1;
						}

						else if (near == abs(temp - data[middle]))
							near_count++;
					}

					else
					{
						if (near > abs(temp - data[left]))
						{
							near = abs(temp - data[left]);
							near_count = 1;
						}

						else if (near == abs(temp - data[left]))
							near_count++;
					}
					break;
				}

				else
				{
					right = middle;
					middle = (left + right) / 2;
				}
			}

			else												
			{
				if (near > abs(temp - data[middle]))
				{
					near = abs(temp - data[middle]);
					near_count = 1;
				}

				else if (near == abs(temp - data[middle]))
					near_count++;

				break;
			}

		}
	}

	printf("%d\n", near_count);
	
}
