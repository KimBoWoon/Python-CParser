

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct point
{
	int x;
	int y;
} Point;
static int compare_pointxy(const void *a, const void *b);
static int compare_reversy(const void *a, const void *b);
void pointlabel(const int pointcount);
void yposrevers(int startpoint,int pointcount);
Point pt[100005];

int main()
{
	FILE *infile;
	int testcase,pointnum;
	int getpoint;
	int getpointnum;
	int i,j;
	int cafenumber[10];
	infile = fopen("input.txt","r");

	fscanf(infile, "%d", &testcase);

	for (i = 0; i < testcase; i++)
	{
		fscanf(infile, "%d", &pointnum);
		memset(pt, 0, sizeof(int) * 100005);
		for (j = 0; j < pointnum; j++)
		{
			fscanf(infile, "%d %d", &pt[j].x, &pt[j].y);
		}
		fscanf(infile, "%d", &getpointnum);
		for (j = 0; j < getpointnum; j++)
		{
			fscanf(infile, "%d", &getpoint);
			cafenumber[j] = getpoint;

		}
		pointlabel(pointnum);
		for (j = 0; j < getpointnum; j++)
		{
			printf("%d %d\n", pt[cafenumber[j] - 1].x, pt[cafenumber[j] - 1].y);
		}
		
	}
	fclose(infile);         
	return 0;
}
int compare_pointxy(const void *a, const void *b)
{
	if (((Point*)a)->x == ((Point*)b)->x)
		return ((Point*)a)->y - ((Point*)b)->y;
	return ((Point*)a)->x - ((Point*)b)->x;
}

int compare_reversy(const void *a, const void *b)
{
	if (((Point*)a)->x == ((Point*)b)->x)
		return ((Point*)b)->y - ((Point*)a)->y;
	return ((Point*)a)->x - ((Point*)b)->x;
}

void pointlabel(const int pointcount)
{
	int currentpos = 0;
	qsort(pt, pointcount, sizeof(Point), compare_pointxy);

	if (pt[0].y != 0)
	{
		yposrevers(0, pointcount);
	}

	while (pointcount-1 > currentpos)
	{
		if (pt[currentpos].x != pt[currentpos + 1].x)
		{
			if (pt[currentpos].y != pt[currentpos + 1].y)
			{
				yposrevers(currentpos + 1,pointcount);
			}
			else
			{
				currentpos++;
			}
		}
		else
		{
			currentpos++;
		}
	}
}
void yposrevers(int startpoint, int pointcount)
{
	int currentxpos = pt[startpoint].x;
	int endpoint = startpoint;
	int count = 0;
	while (endpoint < pointcount && pt[endpoint].x == currentxpos)
	{
		count++;
		endpoint++;
	}
	qsort(pt + startpoint, count, sizeof(Point), compare_reversy);
}
