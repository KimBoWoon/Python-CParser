#include <iostream>
#include <fstream>
#include <cstdlib>

struct pos {
	int x;
	int y;
};

typedef struct pos Pos;

void game(Pos* p, int* result_count_arr, int count, int result_count);
int compare_x(const void *p1, const void *p2);
int compare_y(const void *p1, const void *p2);

int main(void) {

	int testcase = 0;
	Pos* p;
	int* result_count_arr;
	std::ifstream inFile("input.txt");
	inFile >> testcase;

	for (int i = 0; i < testcase; i++) {
		int count = 0;
		inFile >> count;
		p = new Pos[count];

		for (int j = 0; j < count; j++){
			inFile >> p[j].x >> p[j].y;
		}

		int result_count = 0;
		inFile >> result_count;
		result_count_arr = new int[result_count];
		for (int j = 0; j < result_count; j++){
			inFile >> result_count_arr[j];
		}

		game(p, result_count_arr, count, result_count);
		delete p;
	}
	
	return 0;
}

void game(Pos* p, int* result_count_arr, int count, int result_count) {

	qsort((void*)p, count, sizeof(Pos), compare_x);
	int j, k, l;
	Pos* result = new Pos[count];
	int same_x_count = 0;
	if (p[0].y == 0)   {      
		for (j = 1; j<count; j++)   {
			if (p[j].x == p[j - 1].x)
				continue;
			else   {
				if (p[j].y == p[j - 1].y)
					continue;
				else   {
					for (k = j; k<count; k++)   {   
						if (p[k].x == p[k + 1].x)
							same_x_count++;      
						else   {
							same_x_count++;
							qsort((void *)(p + j), same_x_count, sizeof(Pos), compare_y);   
							same_x_count = 0;
							break;
						}
						if (k == count - 1) {
							qsort((void *)(p + j), same_x_count, sizeof(Pos), compare_y);   
							same_x_count = 0;
							break;
						}
					}
				}
			}
		}
	}

	else   {   
		for (j = 0; j<count; j++)   {      
			if (p[j].x == p[j + 1].x)   {
				same_x_count++;
			}
			else   {
				qsort((void *)p, same_x_count + 1, sizeof(Pos), compare_y);
				same_x_count = 0;
				break;
			}
			if (j == count - 1) {
				qsort((void *)p, same_x_count, sizeof(Pos), compare_y);
				same_x_count = 0;
				break;
			}
		}
		for (k = j + 1; k<count; k++)   {   
			if (p[k].x == p[k - 1].x)
				continue;
			else   {
				if (p[k].y == p[k - 1].y)
					continue;
				else   {
					for (l = k; l<count; l++)   {
						if (p[l].x == p[l + 1].x)
							same_x_count++;
						else   {
							same_x_count++;
							qsort((void *)(p + k), same_x_count, sizeof(Pos), compare_y);
							same_x_count = 0;
							break;
						}
						if (l == count - 1) {
							qsort((void *)(p + k), same_x_count, sizeof(Pos), compare_y);
							same_x_count = 0;
							break;
						}
					}
				}
			}
		}
	}
	for (int j = 0; j < result_count; j++){
		std::cout << p[result_count_arr[j] - 1].x << " " << p[result_count_arr[j] - 1].y << std::endl;
	}
	delete result;
}

int compare_x(const void *p1, const void *p2){
	if ((*(Pos*)p1).x - (*(Pos*)p2).x > 0){
		return 1;
	}
	else if ((*(Pos*)p1).x - (*(Pos*)p2).x < 0){
		return -1;
	}
	else{
		if ((*(Pos*)p1).y - (*(Pos*)p2).y > 0)
			return 1;
		else if ((*(Pos*)p1).y - (*(Pos*)p2).y < 0){
			return -1;
		}
	}
}

int compare_y(const void *p1, const void *p2){
	if ((*(Pos*)p1).y - (*(Pos*)p2).y > 0 ){
		return -1;
	}
	else if ((*(Pos*)p1).y - (*(Pos*)p2).y < 0){
		return 1;
	}
}
