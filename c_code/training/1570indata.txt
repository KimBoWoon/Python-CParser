#include <iostream> 
#include <fstream>  
#include <cstdlib> 
using namespace std;   


const int MAX_SIZE = 9;	
static int direction[8][2] = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}}; 



class KnightTour {  
public:    
	KnightTour();      
	KnightTour(int sizeRow, int sizeCol);   
	bool buildKnightTour(int startRow, int startCol);      
	void printBoard();  
private: 
	typedef int boardType[MAX_SIZE][MAX_SIZE];             
	bool recurKnightTour(int startRow, int startCol,int move);       
	bool isValidMove (int row, int col);   
	int sizeRow, sizeCol;      
	boardType board;	
};   

KnightTour::KnightTour() {   
	sizeRow = sizeCol = 8;	
}   


KnightTour::KnightTour(int sRow, int sCol) { 
	if (sRow>=2 && sRow<=MAX_SIZE)	   
		sizeRow = sRow;     
	else          
		sizeRow = 8;	   

	if (sCol>=2 && sCol<=MAX_SIZE)	     
		sizeCol = sCol;      
	else          
		sizeCol = 8;	
} 


void KnightTour::printBoard() {      
	for (int r = 0; r < sizeRow; r++)      {          
		for (int c = 0; c < sizeCol; c++)              
			cout << board[r][c] << " ";   
		cout <<endl;      
	}  
} 


bool KnightTour::buildKnightTour(int startRow, int startCol) {      
	for (int r=0; r<sizeRow; r++)          
		for (int c=0; c<sizeCol; c++)              
			board[r][c]= 0; 

	if (startRow <= 0 || startRow > sizeRow)          
		startRow = 0;      

	if (startCol <= 0 || startCol > sizeCol)          
		startCol = 0;   

	board[startRow-1][startCol-1] = 1;  

	return recurKnightTour(startRow-1, startCol-1, 1); 
} 


bool KnightTour::recurKnightTour(int row, int col, int move) {      
	int nextRow, nextCol; 


	if (move == sizeRow*sizeCol)         
		return true;        

	for(int dir=0; dir<8; dir++)     {       
		nextRow = row + direction[dir][0];  
		nextCol = col + direction[dir][1];	 


		if(isValidMove(nextRow, nextCol))         {   
			board[nextRow][nextCol] = move+1;	
			if(recurKnightTour(nextRow, nextCol, move+1)) { 
				return true;	
			} 
			else 
				board[nextRow][nextCol] = 0;	
		}      
	}           

	return false; 
} 


bool KnightTour::isValidMove(int row, int col) {   
	if(row>=sizeRow || row<0)	  
		return false;             

	if(col>=sizeCol || col<0)   
		return false;             

	if(board[row][col] != 0)    
		return false;                   

	else						
		return true;       
}   

int main() {      
	ifstream infile;      
	int nocases;   

	infile.open("input.txt");      
	if (infile.fail())     {          
		cerr << "파일열기 오류" << endl;;          
		exit(1);      
	}   

	infile >> nocases;   

	for(int i=0; i<nocases; i++)     {          
		int sizeRow, sizeCol;          
		int startRow, startCol;   

		infile >> sizeRow >> sizeCol;          
		infile >> startRow >> startCol; 


		KnightTour kTour(sizeRow, sizeCol);   
		if (kTour.buildKnightTour(startRow, startCol)) {         
			cout << 1 << endl;	
			kTour.printBoard();	
		} else          
			cout << 0 << endl;   
	}     

	return 0;
}    
